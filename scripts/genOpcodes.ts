import { writeFile } from "fs/promises";
import { entries } from "../utils/index.ts";

// TODO: the bytecode version matches, but I don't know which RN version discord uses
const HERMES_URL = "https://github.com/facebook/hermes/raw/refs/tags/v0.13.0";
const BYTECODE_URL = `${HERMES_URL}/include/hermes/BCGen/HBC/BytecodeList.def`;
const BUILTINS_URL = `${HERMES_URL}/include/hermes/FrontEndDefs/Builtins.def`;

const opcodes = {} as Record<string, string[]>;
const bigIntOps = {} as Record<string, number[]>;
const functionOps = {} as Record<string, number[]>;
const stringOps = {} as Record<string, number[]>;
const builtins = [] as string[];

parseBytecode(await fetch(BYTECODE_URL).then(res => res.text()));
parseBuiltins(await fetch(BUILTINS_URL).then(res => res.text()));

const src = `\
// auto-generated by genOpcodes.ts

/**
 * Instruction argument types.
 */
export const enum ArgType {
    /** Unsigned 8-bit value */
    UInt8,
    /** Unsigned 8-bit register index */
    Reg8,
    /** Signed 8-bit relative address */
    Addr8,
    /** Unsigned 16-bit value */
    UInt16,
    /** Unsigned 32-bit value */
    UInt32,
    /** Unsigned 32-bit register index */
    Reg32,
    /** Signed 32-bit immediate */
    Imm32,
    /** Signed 32-bit relative address */
    Addr32,
    /** Double-precision floating point number */
    Double,
}

/**
 * Numeric Hermes instruction opcodes.
 */
export enum Opcode { // {{{
${entries(opcodes).map(([op]) => `    ${op},`).join("\n")}
} // }}}

/**
 * Argument type corresponding to {@link Opcode}.
 */
export const opcodeTypes = { // {{{
${entries(opcodes).map(([op, args]) => `    [Opcode.${op}]: [${args.map(a => `ArgType.${a}`).join(", ")}],`).join("\n")}
} as const; // }}}

/**
 * Opcodes which have operands referring to the bigint table.
 */
export const bigIntOperands = { // {{{
${entries(bigIntOps).map(([op, args]) => `    [Opcode.${op}]: [${args.join(", ")}],`).join("\n")}
} as Record<Opcode, number[]>; // }}}

/**
 * Opcodes which have operands referring to the function table.
 */
export const functionOperands = { // {{{
${entries(functionOps).map(([op, args]) => `    [Opcode.${op}]: [${args.join(", ")}],`).join("\n")}
} as Record<Opcode, number[]>; // }}}

/**
 * Opcodes which have operands referring to the string table.
 */
export const stringOperands = { // {{{
${entries(stringOps).map(([op, args]) => `    [Opcode.${op}]: [${args.join(", ")}],`).join("\n")}
} as Record<Opcode, number[]>; // }}}

export enum Builtin { // {{{
${builtins.map(x => `    "${x}",`).join("\n")}
} // }}}

// vim\: set foldenable:
`;

writeFile("decompiler/src/opcodes.ts", src);

function parseBytecode(listing: string) {
    const OPCODE_RE = /^DEFINE_(\S+)_(\d)\((.*)\)$/gm;
    const OPERAND_RE = /^OPERAND_(\S+)_ID\((.*)\)$/gm;

    for (const [, dir, count, operands] of listing.matchAll(OPCODE_RE)) {
        const [op, ...args] = operands.split(/, */);

        if (dir == "OPCODE") {
            opcodes[op] = args;
        } else if (dir == "JUMP") {
            const args = Array.from(Array(+count - 1), () => "Reg8");
            opcodes[op] = ["Addr8", ...args];
            opcodes[op + "Long"] = ["Addr32", ...args];
        } else {
            throw Error(`Unknown definition: ${dir}`);
        }
    }

    for (const [, dir, operands] of listing.matchAll(OPERAND_RE)) {
        const [name, idx] = operands.split(/, */);

        if (dir == "BIGINT") (bigIntOps[name] ??= []).push(+idx - 1);
        else if (dir == "FUNCTION") (functionOps[name] ??= []).push(+idx - 1);
        else if (dir == "STRING") (stringOps[name] ??= []).push(+idx - 1);
        else throw Error(`Unknown definition: ${dir}`);
    }
}

function parseBuiltins(listing: string) {
    const METHOD_RE = /^BUILTIN_METHOD\((.*)\)$/gm;
    const PRIVATE_RE = /^PRIVATE_BUILTIN\((.*)\)$/gm;

    for (const [, args] of listing.matchAll(METHOD_RE)) {
        const [obj, meth] = args.split(/, */);

        builtins.push(`${obj}.${meth}`);
    }

    for (const [, builtin] of listing.matchAll(PRIVATE_RE)) {
        builtins.push(builtin);
    }
}
