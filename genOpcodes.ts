import { writeFile } from "fs/promises";
import { entries } from "@/utils";

const hermesUrl = "https://github.com/facebook/hermes/raw/refs/tags/v0.13.0/";

const bcList = await fetch(hermesUrl + "/include/hermes/BCGen/HBC/BytecodeList.def").then(res => res.text());

const opcodes = {} as Record<string, string[]>;

for (const [, dir, count, operands] of bcList.matchAll(/^DEFINE_(\S+)_(\d)\((.*)\)$/gm)) {
  const [op, ...args] = operands.split(/, */);

  if (dir == "OPCODE") {
    opcodes[op] = args;
  } else if (dir == "JUMP") {
    const args = Array.from(Array(+count - 1), () => "Reg8");
    opcodes[op] = ["Addr8", ...args];
    opcodes[op + "Long"] = ["Addr32", ...args];
  } else {
    throw dir;
  }
}

const bigintOps = {} as Record<string, number[]>;
const functionOps = {} as Record<string, number[]>;
const stringOps = {} as Record<string, number[]>;

for (const [, dir, operands] of bcList.matchAll(/^OPERAND_(\S+)_ID\((.*)\)/gm)) {
  const [name, idx] = operands.split(/, */);

  if (dir == "BIGINT") (bigintOps[name] ??= []).push(+idx);
  else if (dir == "FUNCTION") (functionOps[name] ??= []).push(+idx);
  else if (dir == "STRING") (stringOps[name] ??= []).push(+idx);
}

const stringify = (val: any) =>
  Array.isArray(val)
    ? `[${val.map(v => JSON.stringify(v)).join(", ")}]`
    : JSON.stringify(val);

let src = `\
// auto-generated by genOpcodes.ts

/**
 * Numeric Hermes instruction opcodes.
 */
export const enum Opcode { // {{{
${entries(opcodes).map(([op]) => `  ${op},`).join("\n")}
} // }}}

/**
 * Argument type corresponding to {@link Opcode}.
 */
export const opcodeTypes = { // {{{
${entries(opcodes).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
}; // }}}

/**
 * Opcodes which have operands referring to the bigint table.
 */
export const bigintOperands = { // {{{
${entries(bigintOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
}; // }}}

/**
 * Opcodes which have operands referring to the function table.
 */
export const functionOperands = { // {{{
${entries(functionOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
}; // }}}

/**
 * Opcodes which have operands referring to the string table.
 */
export const stringOperands = { // {{{
${entries(stringOps).map(([op, args]) => `  [Opcode.${op}]: ${stringify(args)},`).join("\n")}
}; // }}}

// vim: set foldenable:
`;

writeFile("src/opcodes.ts", src);
