import { writeFile } from "fs/promises";
import { entries } from "../utils/index.ts";

// TODO: the bytecode version matches, but I don't know which RN version discord uses
const HERMES_URL = "https://github.com/facebook/hermes/raw/refs/tags/v0.13.0";
const BYTECODE_URL = `${HERMES_URL}/include/hermes/BCGen/HBC/BytecodeList.def`;
const BUILTINS_URL = `${HERMES_URL}/include/hermes/FrontEndDefs/Builtins.def`;

const opcodes = {} as Record<string, string[]>;
const bigIntOps = {} as Record<string, number[]>;
const functionOps = {} as Record<string, number[]>;
const stringOps = {} as Record<string, number[]>;
const builtins = [] as string[];
const longOpcodes = {} as Record<string, string>;

parseBytecode(await fetch(BYTECODE_URL).then(res => res.text()));
parseBuiltins(await fetch(BUILTINS_URL).then(res => res.text()));

const src = `\
// auto-generated by genOpcodes.ts

/**
 * Instruction argument types.
 */
export const enum ArgType {
    /** Unsigned 8-bit value */
    UInt8,
    /** Unsigned 8-bit register index */
    Reg8,
    /** Signed 8-bit relative address */
    Addr8,
    /** Unsigned 16-bit value */
    UInt16,
    /** Unsigned 32-bit value */
    UInt32,
    /** Unsigned 32-bit register index */
    Reg32,
    /** Signed 32-bit immediate */
    Imm32,
    /** Signed 32-bit relative address */
    Addr32,
    /** Double-precision floating point number */
    Double,
}

/**
 * Numeric Hermes instruction opcodes.
 */
export enum Opcode { //#region
${entries(opcodes).map(([op]) => `    ${op},`).join("\n")}
} //#endregion

export type OpcodeMap<T> = Readonly<Partial<Record<Opcode, T>>>;

export type OperandSet = OpcodeMap<readonly number[]>;

/**
 * Argument type corresponding to {@link Opcode}.
 */
export const opcodeTypes = { //#region
${entries(opcodes).map(([op, args]) => `    [Opcode.${op}]: [${args.map(a => `ArgType.${a}`).join(", ")}],`).join("\n")}
} as const; //#endregion

/**
 * Opcodes which have operands referring to the bigint table.
 */
const BIGINT_OPERANDS = { //#region
${entries(bigIntOps).map(([op, args]) => `    [Opcode.${op}]: [${args.join(", ")}],`).join("\n")}
} as const; //#endregion
export type BigIntOperands = typeof BIGINT_OPERANDS;
export const bigintOperands: OperandSet = BIGINT_OPERANDS;

/**
 * Opcodes which have operands referring to the function table.
 */
const FUNCTION_OPERANDS = { //#region
${entries(functionOps).map(([op, args]) => `    [Opcode.${op}]: [${args.join(", ")}],`).join("\n")}
} as const; //#endregion
export type FunctionOperands = typeof FUNCTION_OPERANDS;
export const functionOperands: OperandSet = FUNCTION_OPERANDS;

/**
 * Opcodes which have operands referring to the string table.
 */
const STRING_OPERANDS = { //#region
${entries(stringOps).map(([op, args]) => `    [Opcode.${op}]: [${args.join(", ")}],`).join("\n")}
} as const; //#endregion
export type StringOperands = typeof STRING_OPERANDS;
export const stringOperands: OperandSet = STRING_OPERANDS;

export enum Builtin { //#region
${builtins.map(x => `    "${x}",`).join("\n")}
} //#endregion

export const longOpcodes: OpcodeMap<Opcode> = { //#region
${entries(longOpcodes).map(([short, long]) => `    [Opcode.${short}]: Opcode.${long},`).join("\n")}
}; //#endregion

// vim\: set foldenable foldmarker=//#region,//#endregion:
`;

writeFile("decompiler/src/opcodes.ts", src);

function parseBytecode(listing: string) {
    const OPCODE_RE = /^DEFINE_(\S+)_(\d)\((.*)\)$/gm;
    const OPERAND_RE = /^OPERAND_(\S+)_ID\((.*)\)$/gm;

    const SHORT_RE = /Short$/;
    const LONG_RE = /Long(Index)?$/;

    for (const [, dir, count, operands] of listing.matchAll(OPCODE_RE)) {
        const [op, ...args] = operands.split(/, */);

        if (dir == "OPCODE") {
            opcodes[op] = args;
            if (SHORT_RE.test(op)) longOpcodes[op] = op.replace(SHORT_RE, "");
            if (LONG_RE.test(op)) longOpcodes[op.replace(LONG_RE, "")] = op;
        } else if (dir == "JUMP") {
            const args = Array.from(Array(+count - 1), () => "Reg8");
            opcodes[op] = ["Addr8", ...args];
            opcodes[op + "Long"] = ["Addr32", ...args];
            longOpcodes[op] = op + "Long";
        } else {
            throw Error(`Unknown definition: ${dir}`);
        }
    }

    for (const [, dir, operands] of listing.matchAll(OPERAND_RE)) {
        const [name, idx] = operands.split(/, */);

        if (dir == "BIGINT") (bigIntOps[name] ??= []).push(+idx - 1);
        else if (dir == "FUNCTION") (functionOps[name] ??= []).push(+idx - 1);
        else if (dir == "STRING") (stringOps[name] ??= []).push(+idx - 1);
        else throw Error(`Unknown definition: ${dir}`);
    }
}

function parseBuiltins(listing: string) {
    const METHOD_RE = /^BUILTIN_METHOD\((.*)\)$/gm;
    const PRIVATE_RE = /^PRIVATE_BUILTIN\((.*)\)$/gm;

    for (const [, args] of listing.matchAll(METHOD_RE)) {
        const [obj, meth] = args.split(/, */);

        builtins.push(`${obj}.${meth}`);
    }

    for (const [, builtin] of listing.matchAll(PRIVATE_RE)) {
        builtins.push(builtin);
    }
}
